# MeetingEZ 音频架构文档

## 架构概述

MeetingEZ 采用 **AudioWorklet + Web Worker 双线程架构**，确保音频采集零遗漏。

### 设计目标

1. **零音频丢失**：音频采集运行在独立的音频线程，不受主线程任何操作影响
2. **高性能编码**：WAV 编码在 Worker 线程进行，不阻塞主线程和音频线程
3. **并发上传**：支持多段音频同时编码和上传，降低端到端延迟

### 线程架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        音频设备（麦克风/标签页）                  │
└─────────────────────┬───────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────────┐
│  AudioWorklet 线程（音频线程，高优先级，实时处理）                │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  audio-processor.js                                        │ │
│  │  - 每 2048 样本采集一次                                     │ │
│  │  - 计算 RMS 音量                                            │ │
│  │  - 将音频数据发送到主线程                                   │ │
│  │  - 永不阻塞，确保零丢失                                     │ │
│  └────────────────────────────────────────────────────────────┘ │
└─────────────────────┬───────────────────────────────────────────┘
                      │ MessageChannel
                      ▼
┌─────────────────────────────────────────────────────────────────┐
│  主线程（UI 线程，负责调度和展示）                                │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  app.js                                                    │ │
│  │  - 接收音频数据并累积到缓冲区                               │ │
│  │  - VAD 检测（静音过滤）                                     │ │
│  │  - 8秒窗口分段（1秒重叠）                                   │ │
│  │  - 将窗口数据发送到 Worker 编码                             │ │
│  │  - 处理上传响应和后置处理                                   │ │
│  │  - 更新 UI 显示                                             │ │
│  └────────────────────────────────────────────────────────────┘ │
└───────────┬─────────────────────────────────────────────────────┘
            │ postMessage                    ▲ onmessage
            ▼                                │
┌─────────────────────────────────────────────────────────────────┐
│  Web Worker 线程（编码线程，CPU 密集型）                         │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  wav-encoder-worker.js                                     │ │
│  │  - 接收 Float32Array 音频数据                               │ │
│  │  - 同步转换为 Int16 PCM                                     │ │
│  │  - 封装 WAV 文件头                                          │ │
│  │  - 返回 Blob 到主线程                                       │ │
│  │  - 可并发处理多个编码任务                                   │ │
│  └────────────────────────────────────────────────────────────┘ │
└─────────────────────┬───────────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────────┐
│  主线程 - 上传到 OpenAI API                                      │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  - 创建 FormData                                            │ │
│  │  - 异步上传到 /v1/audio/transcriptions                      │ │
│  │  - 并发控制（允许多个同时上传）                             │ │
│  │  - 后置处理（翻译、纠错）                                    │ │
│  └────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

## 关键组件

### 1. AudioWorklet Processor (audio-processor.js)

**运行环境**：AudioWorklet 线程（独立于主线程）

**职责**：
- 实时采集音频，缓冲大小 2048 样本
- 计算 RMS 用于音量指示和 VAD
- 通过 MessageChannel 发送到主线程
- **保证**：永不阻塞，即使主线程卡死也能持续采集

**关键代码**：
```javascript
process(inputs, outputs, parameters) {
    // 每次处理 128 帧（Web Audio 标准）
    // 累积到 2048 样本后发送到主线程
    // 返回 true 继续处理
}
```

### 2. Web Worker (wav-encoder-worker.js)

**运行环境**：独立的 Worker 线程

**职责**：
- 接收 Float32Array 音频数据
- 同步执行 PCM16 转换和 WAV 封装
- 返回 Blob 到主线程
- **保证**：编码在独立线程，不影响音频采集和 UI

**性能**：
- 8秒音频 (48kHz) = 384,000 样本
- PCM16 转换：~5-10ms (视 CPU 而定)
- WAV 封装：~1-2ms
- 总计：~10ms（在独立线程，不阻塞）

### 3. 主线程调度 (app.js)

**职责**：
- 接收来自 AudioWorklet 的音频块
- 累积到缓冲区并按窗口分段
- VAD 静音检测
- 调度编码任务到 Worker
- 处理编码结果并上传
- 后置处理和 UI 更新

**关键变量**：
```javascript
aggregatedBuffer        // 累积音频缓冲（Float32Array）
segmentStartIndex       // 下一窗口起始索引
pendingEncodings        // 待完成的编码任务 Map
activeUploadControllers // 在途上传请求 Set
```

## 数据流

### 正常流程

1. **采集阶段** (AudioWorklet 线程)
   ```
   麦克风 → AudioWorkletProcessor → 每2048样本打包 → postMessage
   ```

2. **累积阶段** (主线程)
   ```
   接收音频块 → 追加到 aggregatedBuffer → 检查是否满足窗口大小
   ```

3. **编码阶段** (Worker 线程)
   ```
   接收窗口数据 → Float32→Int16 → 封装WAV → 返回Blob
   ```

4. **上传阶段** (主线程异步)
   ```
   接收Blob → FormData → fetch OpenAI API → 获取转写结果
   ```

5. **后处理阶段** (主线程异步)
   ```
   转写结果 → 后置处理API → 纠错/翻译 → 更新显示
   ```

### 停止会议流程

1. 用户点击"结束会议" → `stopMeeting()`
2. 设置 `isShuttingDown = true`（阻止新窗口生成）
3. 停止 `mediaStream` 和 `AudioWorklet`
4. **保留**所有在途任务：
   - `pendingEncodings`（编码中）
   - `activeUploadControllers`（上传中）
   - 后置处理任务
5. 等待所有任务自然完成
6. 显示完成状态

## 性能特性

### 零丢失保证

1. **AudioWorklet 隔离**：音频采集在高优先级独立线程，不受主线程任何操作影响
2. **轻量消息传递**：只传递必要数据（2048样本/次），主线程处理极快
3. **异步编码**：编码在 Worker，主线程立即返回继续处理下一块
4. **大缓冲容忍**：即使编码积压，音频仍持续累积到 `aggregatedBuffer`

### 延迟优化

1. **并发编码**：多个窗口可同时在 Worker 中编码
2. **并发上传**：允许多个转写请求同时进行
3. **分段重叠**：1秒重叠确保边界词不丢失
4. **即时显示**：转写结果先显示临时文本，后处理完成后更新

### 资源管理

1. **缓冲修剪**：`aggregatedBuffer` 定期清理旧数据
2. **任务追踪**：`pendingEncodings` 和 `activeUploadControllers` 管理生命周期
3. **优雅关闭**：停止时保留在途任务，避免丢失最后内容

## 浏览器兼容性

| 浏览器 | AudioWorklet | Web Worker | 最低版本 |
|--------|--------------|------------|----------|
| Chrome | ✅ | ✅ | 66+ |
| Edge   | ✅ | ✅ | 79+ |
| Firefox| ✅ | ✅ | 76+ |
| Safari | ✅ | ✅ | 14.1+ |

**注意**：AudioWorklet 要求 HTTPS 或 localhost。

## 测试验证

### 1. 音频完整性测试

**方法**：
1. 播放已知时长的音频（如60秒测试音频）
2. 使用标签页音频捕获模式
3. 检查转写结果时长是否匹配

**预期**：转写结果应覆盖完整60秒，无空白段

### 2. 高负载测试

**方法**：
1. 在主线程执行 CPU 密集操作（如大数组排序）
2. 同时进行音频转写
3. 观察是否有音频丢失

**预期**：
- AudioWorklet 线程不受影响
- 编码可能略有延迟，但不影响采集
- 所有音频最终都被处理

### 3. 并发编码测试

**方法**：
1. 快速连续说话，产生多个窗口
2. 观察 `pendingEncodings.size` 峰值
3. 确认所有任务都完成

**预期**：
- 峰值可能达到 3-5 个
- 所有任务最终都完成
- 无任务丢失

### 4. 停止会议测试

**方法**：
1. 持续说话
2. 立即点击"结束会议"
3. 观察控制台日志

**预期**：
- 显示保留的在途任务数量
- 最后几句话仍被转写
- 无内容丢失

## 监控指标

### 关键日志

1. **采集监控**
   ```javascript
   console.log('📦 音频窗口已发送到 Worker 编码:', { 
       id, samples, pendingCount 
   });
   ```

2. **编码监控**
   ```javascript
   console.log('✅ Worker 编码完成，开始上传:', { 
       id, blobSize, remainingTasks 
   });
   ```

3. **上传监控**
   ```javascript
   console.log('📤 上传分段(单通道):', { 
       language, sizeKB, inflight 
   });
   console.log('📥 收到转写(单通道):', { 
       language, length 
   });
   ```

4. **停止监控**
   ```javascript
   console.log('📊 停止录音，但保留处理任务继续完成:', {
       上传中, 编码中
   });
   ```

### 性能指标

- **pendingEncodings.size**：当前待编码任务数（正常 ≤ 3）
- **activeUploadControllers.size**：当前上传中请求数（正常 ≤ 5）
- **aggregatedBuffer.length**：累积音频样本数（周期性修剪）

## 故障排查

### 问题：音频有空白段

**可能原因**：
- VAD 阈值过高，误判为静音
- 网络延迟导致上传失败

**解决**：
- 调低 `vadThreshold`（当前 0.02）
- 检查网络日志

### 问题：延迟较高

**可能原因**：
- 编码积压（pendingEncodings 过多）
- 上传积压（activeUploadControllers 过多）

**解决**：
- 检查 CPU 占用
- 检查网络速度
- 考虑减小窗口大小或增加重叠

### 问题：浏览器崩溃

**可能原因**：
- 内存泄漏（缓冲未清理）
- Worker 未正确关闭

**解决**：
- 确认 `aggregatedBuffer` 定期修剪
- 确认停止时 Worker 被正确清理

---

*最后更新: 2025年10月*

